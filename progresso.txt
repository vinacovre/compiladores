3:42 : refiz uma funcao para printar a symtab (print_symtab_stream), dessa vez ela esta correta e printando bem, aparentemente o symtab ta funcionando bem

3:50 : O symtab nao estava com problemas, porem a interpretacao do retorno do symtab no caso onde nao eh encontrado parece estar incorreta, nem sempre que nao encontramos significa um erro, 
pode ser a primeira vez que um simbolo esta sendo declardo, nesse caso ele nao esta na symtab_stream e nao eh um erro. Eu simplesmente comentei a parte do erro, pq nao julgo um erro

4:22 : Yuji, fiz alguns progressos, sobre aquilo que vc tinha ficado de descobrir, de onde viria o valor das variaveis, 
bom... eles nao ficam armazenados em lugar nenhum, mas no momento em que eh declarado um ele esta no lexeme, dessa forma agora eu consigo printar o valor.
case INTCONST:
	AQUI>>>>>rmovel((char*)lexeme);<<<<<<<<,
        match(INTCONST);
        break;
Porem o assembly gerado ainda nao esta legal.  

5:02 : fiquei empacado na ultima hora tentando entender pq tem um trecho de assembly gerado que eh lixo, se nao fosse esse trecho estaria bom, vou mover pra outras questoes..
quem sabe assim consiguimos mais pontos

6:01 : vo dormir, n to pensando mais mto bem..meio dia acordo ou antes, dai volto a falar , nao vamos conseguir deixar o compilador do jeito ideal mas ta fazendo alguma coisa,
falta entender algumas coisas que nao deveriam acontecer. 
- Algumas que eu gostaria que nao acontecessem: As vezes um label eh printado de forma repetida, nunca poderia acontecer isso, se printar label eh pq foi incrementado o labelcounter,
em algum momento ele esta sendo printado sem ter sido incrementado, e com o corpo vazio
- Pode demorar, mas se vc usar como entrada

var will, y, sumexample : integer;
begin
    will := 8;
    y := 2;
    sumexample := will + y;
end.

vai perceber que o assembly ta correto ate certo ponto, ate o ponto anterior a atribuicao do valo da soma de will + y no sumexample, a soma ocorre mas nao ta atribuindo pra lugar nenhum, nao lembro
agora se fica na pilha (provavelmente) ou se vai pra algum lugar, sei que depois tem uma impressao de um assembly incorreto

Daria pra preencher o pseudoassembly.c um pouco mais. Eu retirei tudo que nao estava correto, alias, aqueles assemblys estavam corretos porem eles precisavam de 2 valores pra funcionar, como a coisa 
funciona de modo recursivo nao temos os assemblys na hora de chamar as funcoes, temos que supor que ja foram colocados nos registradores, com isso o assembly que eu tinha colocado la antes ta errado.
A logica eh aquela mas sem o fato de termos dois valores pra iniciar as coisas. Faltaria preencher pelo menos as funcoes logicas, e depois as floats e por ultimo as doubles que vai ser mais dificil.

Deve haver outras coisas pra fazer to cansado e nao to lembrando...


OBSERVACAO IMPORTANTE: AINDA ESTOU PRINTANDO OS ASSEMBLYS NA TELA AO INVES DE JGOAR PRA UM ARQUIVO, A LINHA QUE JOGA PRA UM ARQUIVO QUE VC TINHA FEITO ESTA LA, SO COMENTEI E DEIXEI O STDOUT POR COMODIDADE
ANTES DE ENTREGARAMOS VAMOS LIMPAR E REVISAR O CODIGO ESTETICAMENTE E TAL, DAI AGENTE DEIXA DO JEITO CERTO. NAO LIMPEM O CODIGO ANTES DE DECIDIRMOS QUE NAO VAMOS MAIS MEXER.
QUANDO DECIDIRMOS QUE VAMOS ENTREGAR DESSE JEITO DAI AGENTE COMECA A LIMPAR O CODIGO E DEIXAR BONITINHO E TAL.
